
pthslsh: "/"

OS_IS_WINDOWS ?
	pthslsh: "\\"

print: "pinecone v"+VERSION.x.String+"."+VERSION.y.String+"."+VERSION.z.String + " tests"
print

runTestFolder: "unit", tru

runTestFolder: "regression", tru

runTestFolder: "integration", tru

runTestFolder: "unfixed", fls

print: "tests done"

runTestFolder :: {folder: String, printDetails: Bool}: (
	
	print: (asciiEscape: 1) + (asciiEscape: 3) + in.folder + (asciiEscape: 0)
	print: (asciiEscape: 4) + "interpreted  transpiled   name                              " + (asciiEscape: 0)
	
	filepath: "tests" + pthslsh + in.folder
	
	cmd: String
	
	OS_IS_UNIX ? (
		cmd: "ls " + filepath + pthslsh + " | grep .pn"
	)|(
		cmd: "dir /B " + filepath + " | FINDSTR /C:.pn"
	)
	
	allFiles: runCmd: cmd
	
	i: 0

	j: 0 | j < allFiles.len | j: j+1 @ (
		j = allFiles.len-1 || (allFiles.sub: j, j+1) = "\n" ?(
			name: allFiles.sub: i, j
			runTest: filepath + pthslsh + name, (name.sub: 0, name.len-3), in.printDetails
			i: j+1
		)
	)
	
	print
)

runTest :: {filepath: String, name: String, printDetails: Bool}:
(
	cmdInput: "./pinecone " + in.filepath
	
	resultR: splitActualAndTarget: runCmd: cmdInput + " -r"
	resultE: splitActualAndTarget: runCmd: cmdInput + " -e"
	
	passedR: resultR.actual = resultR.target
	passedE: resultE.actual = resultE.target
	
	summeryLine: String
	
	summeryLine: summeryLine + "    "
	
	passedR ?
		summeryLine: summeryLine + (asciiEscape: 1) + " . " + (asciiEscape: 0)
	|
		summeryLine: summeryLine + (asciiEscape: 91) + "XXX" + (asciiEscape: 0)
	
	summeryLine: summeryLine + "         "
	
	passedE ?
		summeryLine: summeryLine + (asciiEscape: 1) + " . " + (asciiEscape: 0)
	|
		summeryLine: summeryLine + (asciiEscape: 91) + "XXX" + (asciiEscape: 0)
	
	summeryLine: summeryLine + "       "
	
	summeryLine: summeryLine + in.name
	
	print: summeryLine
	
	//
	target = actual ? (
		print: ".\t"+in.name+" passed"
	)|(
		print: "X\t"+in.name+" failed"
		
		in.printDetails ? (
			print: divideLine
			print: "output:"
			print: actual
			print: "instead of:"
			print: target
			print: divideLine
			\\
			//
			j: 0 | j<actual.len | j: j+1 @ (
				j>=target.len ? (
					print: "actual longer then target"
				)| !((actual.sub: j, j+1)=(target.sub: j, j+1)) ? (
					print: "trouble starts at char"
					print: j
					print: (actual.sub: j, j+1).at: 0
					print: "instead of"
					print: (target.sub: j, j+1).at: 0
					j: actual.len
				)
			)
			\\//
		)
	)
	\\
)

asciiEscape :: {Int} -> {String}:
(
	(27).ascii + "[" + in.String + "m"
)

splitActualAndTarget :: {String} -> {actual: String, target: String}:
(
	quit: fls
	i: 0
	target: String
	actual: String
	
	!quit @
	(
		i + targetActualSplit.len >= in.len ? (
			target: "no target"
			in.len = 0 ?
				actual: "no output"
			|
				actual: in
			quit: tru
		)
		| (in.sub: i, i+targetActualSplit.len) = targetActualSplit ?
		(
			target: in.sub: 0, i
			actual: in.sub: i+targetActualSplit.len, in.len
			quit: tru
		)|(
			i: i+1
		)
	)

	actual, target
)

targetActualSplit :: "_____\n"
divideLine :: "_____________________________________________\n"
