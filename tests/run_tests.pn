
pthslsh: "/"

OS_IS_WINDOWS ?
	pthslsh: "\\"

errorDetails: String

print: "pinecone v"+VERSION.x.String+"."+VERSION.y.String+"."+VERSION.z.String + " tests"
print

runTestFolder: "unit", tru

runTestFolder: "regression", tru

runTestFolder: "integration", tru

runTestFolder: "unfixed", fls

print: "tests done"

errorDetails.len > 0 ?
(
	print
	print: "details"
	print: errorDetails
)

runTestFolder :: {folder: String, printDetails: Bool}: (
	
	print: (asciiEscape: 1) + in.folder + (asciiEscape: 0)
	print: (asciiEscape: 2) + (asciiEscape: 3) + "interpreted  transpiled   name                              " + (asciiEscape: 0)
	
	filepath: "tests" + pthslsh + in.folder
	
	cmd: String
	
	OS_IS_UNIX ? (
		cmd: "ls " + filepath + pthslsh + " | grep .pn"
	)|(
		cmd: "dir /B " + filepath + " | FINDSTR /C:.pn"
	)
	
	allFiles: runCmd: cmd
	
	i: 0

	j: 0 | j < allFiles.len | j: j+1 @ (
		j = allFiles.len-1 || (allFiles.sub: j, j+1) = "\n" ?(
			name: allFiles.sub: i, j
			runTest: filepath + pthslsh + name, (name.sub: 0, name.len-3), in.printDetails
			i: j+1
		)
	)
	
	print
)

runTest :: {filepath: String, name: String, showDetails: Bool}:
(
	cmdInput: "./pinecone " + in.filepath
	
	resultR: splitActualAndTarget: runCmd: cmdInput + " -r"
	resultE: splitActualAndTarget: runCmd: cmdInput + " -e"
	
	summeryLine: String
	
	summeryLine: summeryLine + "    "
	summeryLine: summeryLine + (singleTest: resultR.actual, resultR.target, in.name + " interpreted", in.showDetails)
	summeryLine: summeryLine + "         "
	summeryLine: summeryLine + (singleTest: resultE.actual, resultE.target, in.name + " transpiled", in.showDetails)
	summeryLine: summeryLine + "       "
	summeryLine: summeryLine + in.name
	
	print: summeryLine
)

singleTest :: {actual: String, target: String, label: String, expectSuccess: Bool} -> {String}:
(
	out: String
	
	in.actual = in.target ?
	(
		out: (asciiEscape: 1) + " . " + (asciiEscape: 0)
	)|(
		in.expectSuccess ?
			out: (asciiEscape: 91) + "XXX" + (asciiEscape: 0)
		|
			out: "XXX"
		
		in.expectSuccess ?
		(
			actual: String
			target: String
			
			isMatching: fls
			i: 0 | i<in.actual.len | i: i+1 @
			(
				c: in.actual.sub: i, i+1
				isNowMatching: (in.target.len>i) && (in.target.sub: i, i+1)=c
				!(isNowMatching = isMatching) ?
				(
					isNowMatching ?
					(
						actual: actual + (asciiEscape: 0)
						target: target + (asciiEscape: 0)
					)|(
						actual: actual + (asciiEscape: 41) + (asciiEscape: 97)
						target: target + (asciiEscape: 42) + (asciiEscape: 97)
					)
				)
				isMatching: isNowMatching
				
				actual: actual + c
				in.target.len>i ?
					target: target + (in.target.sub: i, i+1)
			)
			
			errorDetails: errorDetails + (asciiEscape: 3) + in.label + (asciiEscape: 0) + "\n"
			errorDetails: errorDetails + (asciiEscape: 1) + "actual:" + (asciiEscape: 0) + "\n"
			errorDetails: errorDetails + actual + (asciiEscape: 0)
			errorDetails: errorDetails + (asciiEscape: 1) + "expected:" + (asciiEscape: 0) + "\n"
			errorDetails: errorDetails + target + (asciiEscape: 0)
			errorDetails: errorDetails + (asciiEscape: 2) + divideLine + (asciiEscape: 0)
		)
	)

	out
)

asciiEscape :: {Int} -> {String}:
(
	(27).ascii + "[" + in.String + "m"
)

splitActualAndTarget :: {String} -> {actual: String, target: String}:
(
	quit: fls
	i: 0
	target: String
	actual: String
	
	!quit @
	(
		i + targetActualSplit.len >= in.len ? (
			target: "no target"
			in.len = 0 ?
				actual: "no output"
			|
				actual: in
			quit: tru
		)
		| (in.sub: i, i+targetActualSplit.len) = targetActualSplit ?
		(
			target: in.sub: 0, i
			actual: in.sub: i+targetActualSplit.len, in.len
			quit: tru
		)|(
			i: i+1
		)
	)

	actual, target
)

targetActualSplit :: "_____\n"
divideLine :: (asciiEscape: 2) + "==========================================================\n" + (asciiEscape: 0)
